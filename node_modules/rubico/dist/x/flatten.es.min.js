/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,__=Symbol.for("placeholder"),arrayPush=function(t,r){return t.push(r),t},always=t=>function(){return t},curry2ResolveArg0=(t,r)=>function(e){return t(e,r)},curry2ResolveArg1=(t,r)=>function(e){return t(r,e)},curry2=function(t,r,e){return r==__?curry2ResolveArg0(t,e):curry2ResolveArg1(t,r)},getArg1=(t,r)=>r,identity=t=>t,isPromise=t=>null!=t&&"function"==typeof t.then,promiseAll=Promise.all.bind(Promise),funcConcatSync=(t,r)=>function(...e){return r(t(...e))},asyncIteratorForEach=async function(t,r){const e=[];for await(const n of t){const t=r(n);isPromise(t)&&e.push(t)}return 0==e.length?t:promiseAll(e).then(always(t))},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,arrayFlatten=function(t){const r=t.length,e=[],n=[];let o=-1;for(;++o<r;){const r=t[o];if(isArray(r)){const t=r.length;let e=-1;for(;++e<t;)n.push(r[e])}else if(null==r)n.push(r);else if("function"==typeof r.then)e.push(r.then(curry2(arrayPush,n,__)));else if("function"==typeof r[symbolIterator])for(const t of r)n.push(t);else if("function"==typeof r[symbolAsyncIterator])e.push(asyncIteratorForEach(r[symbolAsyncIterator](),curry2(arrayPush,n,__)));else if("function"==typeof r.chain){const t=r.chain(identity);isPromise(t)?e.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof r.flatMap){const t=r.flatMap(identity);isPromise(t)?e.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof r.reduce){const t=r.reduce(funcConcatSync(getArg1,curry2(arrayPush,n,__)),null);isPromise(t)&&e.push(t)}else if(r.constructor==Object)for(const t in r)n.push(r[t]);else n.push(r)}return 0==e.length?n:promiseAll(e).then(always(n))},curry3ResolveArg0=(t,r,e)=>function(n){return t(n,r,e)},curry3ResolveArg1=(t,r,e)=>function(n){return t(r,n,e)},curry3ResolveArg2=(t,r,e)=>function(n){return t(r,e,n)},curry3=function(t,r,e,n){return r==__?curry3ResolveArg0(t,e,n):e==__?curry3ResolveArg1(t,r,n):curry3ResolveArg2(t,r,e)},callPropUnary=(t,r,e)=>t[r](e),setFlatten=function(t){t.size;const r=[],e=new Set,n=(t,r)=>e.add(r),o=curry3(callPropUnary,e,"add",__);for(const c of t)if(isArray(c)){const t=c.length;let r=-1;for(;++r<t;)e.add(c[r])}else if(null==c)e.add(c);else if("function"==typeof c[symbolIterator])for(const t of c)e.add(t);else if("function"==typeof c[symbolAsyncIterator])r.push(asyncIteratorForEach(c[symbolAsyncIterator](),o));else if("function"==typeof c.chain){const t=c.chain(identity);isPromise(t)?r.push(t.then(o)):e.add(t)}else if("function"==typeof c.flatMap){const t=c.flatMap(identity);isPromise(t)?r.push(t.then(o)):e.add(t)}else if("function"==typeof c.reduce){const t=c.reduce(n,null);isPromise(t)&&r.push(t)}else if(c.constructor==Object)for(const t in c)e.add(c[t]);else e.add(c);return 0==r.length?e:promiseAll(r).then((()=>e))},objectAssign=Object.assign,objectFlatten=function(t){const r=[],e={},n=curry2(objectAssign,e,__),o=funcConcatSync(getArg1,n);for(const c in t){const i=t[c];if(null!=i)if("function"==typeof i[symbolIterator])for(const t of i)objectAssign(e,t);else if("function"==typeof i[symbolAsyncIterator])r.push(asyncIteratorForEach(i[symbolAsyncIterator](),n));else if("function"==typeof i.chain){const t=i.chain(identity);isPromise(t)?r.push(t.then(n)):objectAssign(e,t)}else if("function"==typeof i.flatMap){const t=i.flatMap(identity);isPromise(t)?r.push(t.then(n)):n(t)}else if("function"==typeof i.reduce){const t=i.reduce(o,null);isPromise(t)&&r.push(t)}else objectAssign(e,i)}return 0==r.length?e:promiseAll(r).then((()=>e))},objectValues=Object.values,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=t=>nativeObjectToString.call(t),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=t=>objectToString(t)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=t=>objectToString(t)==asyncGeneratorFunctionTag,iteratorReduceAsync=async function(t,r,e){let n=t.next();if(n.done)return e;for(;!n.done;)e=r(e,n.value),isPromise(e)&&(e=await e),n=t.next();return e},iteratorReduce=function(t,r,e){let n=t.next();if(n.done)return e;for(void 0===e&&(e=n.value,n=t.next());!n.done;){if(e=r(e,n.value),isPromise(e))return e.then(curry3(iteratorReduceAsync,t,r,__));n=t.next()}return e},asyncIteratorReduce=async function(t,r,e){let n=await t.next();if(n.done)return e;for(void 0===e&&(e=n.value,n=await t.next());!n.done;)e=await r(e,n.value),n=await t.next();return e},curryArgs3ResolveArgs0=(t,r,e)=>function(...n){return t(n,r,e)},curryArgs3ResolveArgs1=(t,r,e)=>function(...n){return t(r,n,e)},curryArgs3ResolveArgs2=(t,r,e)=>function(...n){return t(r,e,n)},curryArgs3=function(t,r,e,n){return r==__?curryArgs3ResolveArgs0(t,e,n):e==__?curryArgs3ResolveArgs1(t,r,n):curryArgs3ResolveArgs2(t,r,e)},curry4ResolveArg0=(t,r,e,n)=>function(o){return t(o,r,e,n)},curry4ResolveArg1=(t,r,e,n)=>function(o){return t(r,o,e,n)},curry4ResolveArg2=(t,r,e,n)=>function(o){return t(r,e,o,n)},curry4ResolveArg3=(t,r,e,n)=>function(o){return t(r,e,n,o)},curry4=function(t,r,e,n,o){return r==__?curry4ResolveArg0(t,e,n,o):e==__?curry4ResolveArg1(t,r,n,o):n==__?curry4ResolveArg2(t,r,e,o):curry4ResolveArg3(t,r,e,n)},arrayReduceAsync=async function(t,r,e,n){const o=t.length;for(;++n<o;)e=r(e,t[n],n,t),isPromise(e)&&(e=await e);return e},arrayReduce=function(t,r,e){const n=t.length;let o=-1;for(void 0===e&&(e=t[++o]);++o<n;)if(e=r(e,t[o],o,t),isPromise(e))return e.then(curry4(arrayReduceAsync,t,r,__,o));return e},curry5ResolveArg0=(t,r,e,n,o)=>function(c){return t(c,r,e,n,o)},curry5ResolveArg1=(t,r,e,n,o)=>function(c){return t(r,c,e,n,o)},curry5ResolveArg2=(t,r,e,n,o)=>function(c){return t(r,e,c,n,o)},curry5ResolveArg3=(t,r,e,n,o)=>function(c){return t(r,e,n,c,o)},curry5ResolveArg4=(t,r,e,n,o)=>function(c){return t(r,e,n,o,c)},curry5=function(t,r,e,n,o,c){return r==__?curry5ResolveArg0(t,e,n,o,c):e==__?curry5ResolveArg1(t,r,n,o,c):n==__?curry5ResolveArg2(t,r,e,o,c):o==__?curry5ResolveArg3(t,r,e,n,c):curry5ResolveArg4(t,r,e,n,o)},objectKeys=Object.keys,objectGetFirstKey=function(t){for(const r in t)return r},objectReduceAsync=async function(t,r,e,n,o){const c=n.length;for(;++o<c;){const c=n[o];e=r(e,t[c],c,t),isPromise(e)&&(e=await e)}return e},objectReduce=function(t,r,e){const n=objectKeys(t),o=n.length;let c=-1;for(void 0===e&&(e=t[n[++c]]);++c<o;){const o=n[c];if(e=r(e,t[o],o,t),isPromise(e))return e.then((i=objectReduceAsync,a=r,u=__,l=n,f=c,(s=t)==__?curry5ResolveArg0(i,a,u,l,f):a==__?curry5ResolveArg1(i,s,u,l,f):u==__?curry5ResolveArg2(i,s,a,l,f):l==__?curry5ResolveArg3(i,s,a,u,f):curry5ResolveArg4(i,s,a,u,l)))}var i,s,a,u,l,f;return e},mapReduceAsync=async function(t,r,e,n){for(const[o,c]of n)e=r(e,c,o,t),isPromise(e)&&(e=await e);return e},mapReduce=function(t,r,e){const n=t.entries();if(void 0===e){const t=n.next();if(t.done)return e;e=t.value[1]}for(const[o,c]of n)if(e=r(e,c,o,t),isPromise(e))return e.then(curry4(mapReduceAsync,t,r,__,n));return e},generatorFunctionReduce=(t,r,e)=>funcConcatSync(t,curry3(iteratorReduce,__,r,e)),asyncGeneratorFunctionReduce=(t,r,e)=>funcConcatSync(t,curry3(asyncIteratorReduce,__,r,e)),reducerConcat=(t,r)=>function(e,n){const o=t(e,n);return isPromise(o)?o.then(curry2(r,__,n)):r(o,n)},genericReduce=function(t,r,e){const n=t[0];return isArray(n)?arrayReduce(n,r,e):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionReduce(n,r,e):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionReduce(n,r,e):curryArgs3(genericReduce,__,1==t.length?reducerConcat(r,n):t.reduce(reducerConcat,r),e):null==n?void 0===e?curry2(r,n,__):r(e,n):n.constructor==Map?mapReduce(n,r,e):"function"==typeof n[symbolIterator]?iteratorReduce(n[symbolIterator](),r,e):"function"==typeof n[symbolAsyncIterator]?asyncIteratorReduce(n[symbolAsyncIterator](),r,e):"function"==typeof n.reduce?n.reduce(r,e):"function"==typeof n.chain?n.chain(curry2(r,e,__)):"function"==typeof n.flatMap?n.flatMap(curry2(r,e,__)):n.constructor==Object?objectReduce(n,r,e):void 0===e?curry2(r,n,__):r(e,n)},FlatMappingIterator=function(t,r){let e=[],n=0;return{[symbolIterator](){return this},next(){if(n<e.length){const t=e[n];return n+=1,{value:t,done:!1}}const o=t.next();if(o.done)return o;const c=genericReduce([r(o.value)],arrayPush,[]);return c.length>1&&(e=c,n=1),{value:c[0],done:!1}}}},FlatMappingAsyncIterator=function(t,r){const e=[],n=new Set;return{[symbolAsyncIterator](){return this},toString:()=>"[object FlatMappingAsyncIterator]",async next(){if(e.length>0)return{value:e.shift(),done:!1};const{value:o,done:c}=await t.next();if(c){for(;n.size>0;)if(await new Promise((t=>setTimeout(t,25))),e.length>0)return{value:e.shift(),done:!1};return{value:void 0,done:!0}}const i=r(o);if(isPromise(i)){const t=i.then(curryArgs3(genericReduce,__,arrayPush,e)).then((()=>n.delete(t)));n.add(t)}else{const t=genericReduce([i],arrayPush,e);if(e.length>0)return{value:e.shift(),done:!1};if(isPromise(t)){const r=t.then((()=>n.delete(r)));n.add(r)}}for(;n.size>0;)if(await new Promise((t=>setTimeout(t,25))),e.length>0)return{value:e.shift(),done:!1};return{value:void 0,done:!0}}}},isBinary=ArrayBuffer.isView,arrayMap=function(t,r){const e=t.length,n=Array(e);let o=-1,c=!1;for(;++o<e;){const e=r(t[o],o,t);isPromise(e)&&(c=!0),n[o]=e}return c?promiseAll(n):n},arrayFlatMap=function(t,r){const e=arrayMap(t,r);return isPromise(e)?e.then(arrayFlatten):arrayFlatten(e)},promiseObjectAllExecutor=t=>function(r){const e={};let n=0;for(const o in t){const c=t[o];isPromise(c)?(n+=1,c.then((t=>function(o){e[t]=o,n-=1,0==n&&r(e)})(o))):e[o]=c}0==n&&r(e)},promiseObjectAll=t=>new Promise(promiseObjectAllExecutor(t)),objectMap=function(t,r){const e={};let n=!1;for(const o in t){const c=r(t[o],o,t);isPromise(c)&&(n=!0),e[o]=c}return n?promiseObjectAll(e):e},objectFlatMap=function(t,r){const e=objectMap(t,r);return isPromise(e)?e.then(objectFlatten):objectFlatten(e)},setMap=function(t,r){const e=new Set,n=[];for(const o of t){const c=r(o,o,t);isPromise(c)?n.push(c.then(curry3(callPropUnary,e,"add",__))):e.add(c)}return 0==n.length?e:promiseAll(n).then(always(e))},setFlatMap=function(t,r){const e=setMap(t,r);return isPromise(e)?e.then(setFlatten):setFlatten(e)},funcConcat=(t,r)=>function(...e){const n=t(...e);return isPromise(n)?n.then(r):r(n)},arrayJoin=(t,r)=>t.join(r),arrayFlattenToString=funcConcat(arrayFlatten,curry2(arrayJoin,__,"")),stringFlatMap=function(t,r){const e=arrayMap(t,r);return isPromise(e)?e.then(arrayFlattenToString):arrayFlattenToString(e)},streamWrite=function(t,r,e,n){return t.write(r,e,n),t},streamFlatExtend=async function(t,r){const e=curry2(streamWrite,t,__),n=funcConcatSync(getArg1,e),o=[];if(isArray(r)){const e=r.length;let n=-1;for(;++n<e;)t.write(r[n])}else if(null==r)t.write(r);else if("function"==typeof r[symbolIterator])for(const e of r)t.write(e);else if("function"==typeof r[symbolAsyncIterator])o.push(asyncIteratorForEach(r[symbolAsyncIterator](),e));else if("function"==typeof r.chain){const n=r.chain(identity);isPromise(n)?o.push(n.then(e)):t.write(n)}else if("function"==typeof r.flatMap){const n=r.flatMap(identity);isPromise(n)?o.push(n.then(e)):t.write(n)}else if("function"==typeof r.reduce){const t=r.reduce(n,null);isPromise(t)&&o.push(t)}else if(r.constructor==Object)for(const e in r)t.write(r[e]);else t.write(r);return 0==o.length?t:promiseAll(o).then(always(t))},streamFlatMap=async function(t,r){const e=new Set;for await(const n of t){const o=r(n);if(isPromise(o)){const r=o.then(curry2(streamFlatExtend,t,__)).then((()=>e.delete(r)));e.add(r)}else{const r=streamFlatExtend(t,o);if(isPromise(r)){const t=r.then((()=>e.delete(t)));e.add(t)}}}return await promiseAll(e),t},globalThisHasBuffer="function"==typeof Buffer,noop=function(){},bufferAlloc=globalThisHasBuffer?Buffer.alloc:noop,_binaryExtend=function(t,r){const e=t.length,n=globalThisHasBuffer&&t.constructor==Buffer?bufferAlloc(e+r.length):new t.constructor(e+r.length);return n.set(t),n.set(r,e),n},binaryExtend=function(t,r){return isArray(r)||isBinary(r)?_binaryExtend(t,r):_binaryExtend(t,[r])},arrayJoinToBinary=function(t,r){const e=t.length;let n=-1,o=r;for(;++n<e;)o=binaryExtend(o,t[n]);return o},arrayFlattenToBinary=function(t,r){const e=arrayFlatten(t);return isPromise(e)?e.then(curry2(arrayJoinToBinary,__,r)):arrayJoinToBinary(e,r)},binaryFlatMap=function(t,r){const e=arrayMap(t,r),n=globalThisHasBuffer&&t.constructor==Buffer?bufferAlloc(0):new t.constructor(0);return isPromise(e)?e.then(curry2(arrayFlattenToBinary,__,n)):arrayFlattenToBinary(e,n)},reducerFlatMap=(t,r)=>function(e,n){const o=r(n);return isPromise(o)?o.then(curryArgs3(genericReduce,__,t,e)):genericReduce([o],t,e)},generatorFunctionFlatMap=(t,r)=>function*(...e){yield*FlatMappingIterator(t(...e),r)},asyncGeneratorFunctionFlatMap=(t,r)=>async function*(...e){yield*FlatMappingAsyncIterator(t(...e),r)},flatMap=t=>function(r){if(isArray(r))return arrayFlatMap(r,t);if("function"==typeof r)return isGeneratorFunction(r)?generatorFunctionFlatMap(r,t):isAsyncGeneratorFunction(r)?asyncGeneratorFunctionFlatMap(r,t):reducerFlatMap(r,t);if(isBinary(r))return binaryFlatMap(r,t);if(null==r)return t(r);if("function"==typeof r.then)return r.then(t);if("function"==typeof r.next)return symbolIterator in r?FlatMappingIterator(r,t):FlatMappingAsyncIterator(r,t);if("function"==typeof r.chain)return r.chain(t);if("function"==typeof r.flatMap)return r.flatMap(t);if("function"==typeof r[symbolAsyncIterator]&&"function"==typeof r.write)return streamFlatMap(r,t);const e=r.constructor;return e==Object?objectFlatMap(r,t):e==Set?setFlatMap(r,t):"string"==typeof r||e==String?stringFlatMap(r,t):t(r)},flatten=function(t){return isArray(t)?arrayFlatten(t):null==t?t:t.constructor==Set?setFlatten(t):t.constructor==Object?objectFlatten(t):(r=identity,function(t){if(isArray(t))return arrayFlatMap(t,r);if("function"==typeof t)return isGeneratorFunction(t)?generatorFunctionFlatMap(t,r):isAsyncGeneratorFunction(t)?asyncGeneratorFunctionFlatMap(t,r):reducerFlatMap(t,r);if(isBinary(t))return binaryFlatMap(t,r);if(null==t)return r(t);if("function"==typeof t.then)return t.then(r);if("function"==typeof t.next)return symbolIterator in t?FlatMappingIterator(t,r):FlatMappingAsyncIterator(t,r);if("function"==typeof t.chain)return t.chain(r);if("function"==typeof t.flatMap)return t.flatMap(r);if("function"==typeof t[symbolAsyncIterator]&&"function"==typeof t.write)return streamFlatMap(t,r);const e=t.constructor;return e==Object?objectFlatMap(t,r):e==Set?setFlatMap(t,r):"string"==typeof t||e==String?stringFlatMap(t,r):r(t)})(t);var r};export default flatten;
