/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.forEach=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=Array.isArray,t=Object.prototype.toString,o=n=>t.call(n),e=n=>null!=n&&"function"==typeof n.then,c=Promise.all.bind(Promise),r=n=>function(){return n},u=Symbol.iterator,f=Symbol.asyncIterator;return t=>function(s){return n(s)?function(n,t){const o=n.length,u=[];let f=-1;for(;++f<o;){const o=t(n[f]);e(o)&&u.push(o)}return 0==u.length?n:c(u).then(r(n))}(s,t):"function"==typeof s?(n=>"[object GeneratorFunction]"==o(n))(s)?((n,t)=>function*(...o){const u=[],f=n(...o);for(const n of f){const o=t(n);e(o)&&u.push(o)}return 0==u.length?f:c(u).then(r(f))})(s,t):(n=>"[object AsyncGeneratorFunction]"==o(n))(s)?((n,t)=>async function*(...o){const u=[],f=n(...o);for await(const n of f){const o=t(n);e(o)&&u.push(o)}return 0==u.length?f:c(u).then(r(f))})(s,t):((n,t)=>function(o,c){const r=t(c);return e(r)?r.then((u=n,f=o,s=c,function(){return u(f,s)})):n(o,c);var u,f,s})(s,t):null==s?s:"function"==typeof s.forEach?s.forEach(t):"function"==typeof s[u]?function(n,t){const o=[];for(const c of n){const n=t(c);e(n)&&o.push(n)}return 0==o.length?n:c(o).then(r(n))}(s[u](),t):"function"==typeof s[f]?async function(n,t){const o=[];for await(const c of n){const n=t(c);e(n)&&o.push(n)}return 0==o.length?n:c(o).then(r(n))}(s[f](),t):s.constructor==Object?function(n,t){const o=[];for(const c in n){const r=t(n[c]);e(r)&&o.push(r)}return 0==o.length?n:c(o).then(r(n))}(s,t):s}}());
