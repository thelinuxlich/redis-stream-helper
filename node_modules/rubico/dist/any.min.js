/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(t,n){"object"==typeof module?module.exports=n:"function"==typeof define?define((()=>n)):t.any=n}("object"==typeof globalThis?globalThis:this,function(){"use strict";const t=Array.isArray,n=Object.values,e=function(t){const n=t.then((t=>[t,n]));return n},r=t=>null!=t&&"function"==typeof t.then,o=Promise.race.bind(Promise),i=async function(t,n,i,u){const f=t.length;for(;++i<f;){const o=n(t[i]);if(r(o))u.add(e(o));else if(o)return!0}for(;u.size>0;){const[t,n]=await o(u);if(u.delete(n),t)return!0}return!1},u=function(t,n){const o=t.length;let u=-1;for(;++u<o;){const o=n(t[u]);if(r(o))return i(t,n,u,new Set([e(o)]));if(o)return!0}return!1},f=async function(t,n,i,u=20){let f=t.next();for(r(f)&&(f=await f);!f.done;){if(i.size>=u){const[t,n]=await o(i);if(i.delete(n),t)return!0}const c=n(f.value);if(r(c))i.add(e(c));else if(c)return!0;f=t.next(),r(f)&&(f=await f)}for(;i.size>0;){const[t,n]=await o(i);if(i.delete(n),t)return!0}return!1},c=Symbol.for("placeholder"),s=t=>function(n,e){return!0===n?n:r(n)?n.then((o=(t=>function(n,e){return!!n||t(e)})(t),u=e,(i=c)==c?((t,n)=>function(e){return t(e,n)})(o,u):((t,n)=>function(e){return t(n,e)})(o,i))):!!n||t(e);var o,i,u},a=Symbol.iterator,l=Symbol.asyncIterator;return o=>function(i){return t(i)?u(i,o):null==i?o(i):"function"==typeof i[a]?function(t,n){for(const o of t){const i=n(o);if(r(i))return f(t,n,new Set([e(i)]));if(i)return!0}return!1}(i[a](),o):"function"==typeof i[l]?f(i[l](),o,new Set):"function"==typeof i.reduce?i.reduce(s(o),!1):i.constructor==Object?u(n(i),o):o(i)}}());
