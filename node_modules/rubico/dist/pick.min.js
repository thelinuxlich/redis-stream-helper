/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(t,n){"object"==typeof module?module.exports=n:"function"==typeof define?define((()=>n)):t.pick=n}("object"==typeof globalThis?globalThis:this,function(){"use strict";const t=Array.isArray,n=/[.|[|\]]+/,e=function(t,n){const e=new Map,o=function(o){if(e.has(o))return e.get(o);const r=t(o);return e.set(o,r),e.size>n&&e.clear(),r};return o.cache=e,o}((function(t){const e=t.length-1,o="["==t[0],r="]"==t[e];return o&&r?t.slice(1,e).split(n):o?t.slice(1).split(n):r?t.slice(0,e).split(n):t.split(n)}),500),o=n=>t(n)?n:"string"==typeof n?e(n):[n],r=function(t,n){const e=o(n),r=e.length;let i=-1,c=t;for(;++i<r;)if(c=c[e[i]],null==c)return;return c},i=function(n,e,r){if(!(t=>{if(null==t)return!1;const n=typeof t;return"object"==n||"function"==n})(n))return n;const i=o(r),c=i.length,l=c-1,s={...n};let u=s,f=-1;for(;++f<c;){const n=i[f];if(f==l)u[n]=e;else{const e=u[n],o=t(e)?e.slice():{...e};u[n]=o,u=o}}return s};return t=>function(n){if(null==n)return n;const e=t.length;let o={},c=-1;for(;++c<e;){const e=t[c],l=r(n,e);null!=l&&(o=i(o,l,e))}return o}}());
