/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,memoizeCappedUnary=function(t,e){const r=new Map,n=function(n){if(r.has(n))return r.get(n);const i=t(n);return r.set(n,i),r.size>e&&r.clear(),i};return n.cache=r,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(t){const e=t.length-1,r="["==t[0],n="]"==t[e];return r&&n?t.slice(1,e).split(pathDelimiters):r?t.slice(1).split(pathDelimiters):n?t.slice(0,e).split(pathDelimiters):t.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=t=>isArray(t)?t:"string"==typeof t?memoizedCappedParsePropertyPath(t):[t],getByPath=function(t,e){const r=propertyPathToArray(e),n=r.length;let i=-1,s=t;for(;++i<n;)if(s=s[r[i]],null==s)return;return s},isObject=t=>{if(null==t)return!1;const e=typeof t;return"object"==e||"function"==e},setByPath=function(t,e,r){if(!isObject(t))return t;const n=propertyPathToArray(r),i=n.length,s=i-1,a={...t};let o=a,p=-1;for(;++p<i;){const t=n[p];if(p==s)o[t]=e;else{const e=o[t],r=isArray(e)?e.slice():{...e};o[t]=r,o=r}}return a},pick=t=>function(e){if(null==e)return e;const r=t.length;let n={},i=-1;for(;++i<r;){const r=t[i],s=getByPath(e,r);null!=s&&(n=setByPath(n,s,r))}return n};export default pick;
