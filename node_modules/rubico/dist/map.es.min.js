/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const symbolIterator=Symbol.iterator,MappingIterator=(r,n)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const t=r.next();return t.done?t:{value:n(t.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),isPromise=r=>null!=r&&"function"==typeof r.then,symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,n)=>({[symbolAsyncIterator](){return this},async next(){const t=await r.next();if(t.done)return t;const e=n(t.value);return isPromise(e)?e.then(NextIteration):{value:e,done:!1}}}),isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const n=typeof r;return"object"==n||"function"==n},objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,promiseAll=Promise.all.bind(Promise),arrayMap=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o],o,r);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},generatorFunctionMap=(r,n)=>function*(...t){for(const e of r(...t))yield n(e)},asyncGeneratorFunctionMap=function(r,n){return async function*(...t){for await(const e of r(...t))yield n(e)}},__=Symbol.for("placeholder"),curry2ResolveArg0=(r,n)=>function(t){return r(t,n)},curry2ResolveArg1=(r,n)=>function(t){return r(n,t)},curry2=function(r,n,t){return n==__?curry2ResolveArg0(r,t):curry2ResolveArg1(r,n)},reducerMap=(r,n)=>function(t,e){const o=n(e);return isPromise(o)?o.then((c=r,i=__,(s=t)==__?curry2ResolveArg0(c,i):curry2ResolveArg1(c,s))):r(t,o);var c,s,i},curry3ResolveArg0=(r,n,t)=>function(e){return r(e,n,t)},curry3ResolveArg1=(r,n,t)=>function(e){return r(n,e,t)},curry3ResolveArg2=(r,n,t)=>function(e){return r(n,t,e)},curry3=function(r,n,t,e){return n==__?curry3ResolveArg0(r,t,e):t==__?curry3ResolveArg1(r,n,e):curry3ResolveArg2(r,n,t)},callPropUnary=(r,n,t)=>r[n](t),stringMap=function(r,n){const t=arrayMap(r,n);return isPromise(t)?t.then(curry3(callPropUnary,__,"join","")):t.join("")},always=r=>function(){return r},setMap=function(r,n){const t=new Set,e=[];for(const o of r){const c=n(o,o,r);isPromise(c)?e.push(c.then(curry3(callPropUnary,t,"add",__))):t.add(c)}return 0==e.length?t:promiseAll(e).then(always(t))},curry4ResolveArg0=(r,n,t,e)=>function(o){return r(o,n,t,e)},curry4ResolveArg1=(r,n,t,e)=>function(o){return r(n,o,t,e)},curry4ResolveArg2=(r,n,t,e)=>function(o){return r(n,t,o,e)},curry4ResolveArg3=(r,n,t,e)=>function(o){return r(n,t,e,o)},curry4=function(r,n,t,e,o){return n==__?curry4ResolveArg0(r,t,e,o):t==__?curry4ResolveArg1(r,n,e,o):e==__?curry4ResolveArg2(r,n,t,o):curry4ResolveArg3(r,n,t,e)},callPropBinary=(r,n,t,e)=>r[n](t,e),mapMap=function(r,n){const t=new Map,e=[];for(const[o,c]of r){const s=n(c,o,r);isPromise(s)?e.push(s.then(curry4(callPropBinary,t,"set",o,__))):t.set(o,s)}return 0==e.length?t:promiseAll(e).then(always(t))},promiseObjectAllExecutor=r=>function(n){const t={};let e=0;for(const o in r){const c=r[o];isPromise(c)?(e+=1,c.then((r=>function(o){t[r]=o,e-=1,0==e&&n(t)})(o))):t[o]=c}0==e&&n(t)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,n){const t={};let e=!1;for(const o in r){const c=n(r[o],o,r);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},funcConcat=(r,n)=>function(...t){const e=r(...t);return isPromise(e)?e.then(n):n(e)},objectSet=function(r,n,t){return r[n]=t,r},arrayMapSeriesAsync=async function(r,n,t,e){const o=r.length;for(;++e<o;){const o=n(r[e]);t[e]=isPromise(o)?await o:o}return t},arrayMapSeries=function(r,n){const t=r.length,e=Array(t);let o=-1;for(;++o<t;){const t=n(r[o]);if(isPromise(t))return t.then(funcConcat(curry3(objectSet,e,o,__),curry4(arrayMapSeriesAsync,r,n,__,o)));e[o]=t}return e},tapSync=r=>function(...n){return r(...n),n[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,n,t,e,o,c){const s=r.length;for(;++o<s;){c.size>=t&&await promiseRace(c);const s=n(r[o]);if(isPromise(s)){const r=s.then(tapSync((()=>c.delete(r))));c.add(r),e[o]=r}else e[o]=s}return promiseAll(e)},arrayMapPool=function(r,n,t){const e=r.length,o=Array(e);let c=-1;for(;++c<e;){const e=n(r[c]);if(isPromise(e)){const s=new Set,i=e.then(tapSync((()=>s.delete(i))));return s.add(i),o[c]=i,arrayMapPoolAsync(r,n,t,o,c,s)}o[c]=e}return o},arrayMapWithIndex=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o],o,r);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(r,n)=>hasOwnProperty.call(r,n),objectMapOwn=function(r,n){const t={};let e=!1;for(const o in r)if(hasOwn(r,o)){const c=n(r[o]);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},_curryArity=(r,n,t)=>function(...e){const o=t.length,c=e.length,s=[];let i=-1,a=-1,u=0;for(;++i<o;){const o=t[i];if(o==__&&(a+=1)<c){const r=e[a];r==__&&(u+=1),s.push(r)}else s.push(o);if(s.length==r)return 0==u?n(...s):curryArity(r,n,s)}for(;++a<c;){const t=e[a];if(t==__&&(u+=1),s.push(t),s.length==r)return 0==u?n(...s):curryArity(r,n,s)}return curryArity(r,n,s)},curryArity=function(r,n,t){const e=t.length;if(e<r)return _curryArity(r,n,t);let o=-1;for(;++o<e;){if(t[o]==__)return _curryArity(r,n,t)}return n(...t)},spread2=r=>function([n,t]){return r(n,t)},objectMapEntries=function(r,n){const t={},e=[];for(const o in r){const c=n([o,r[o]]);isPromise(c)?e.push(c.then(spread2(curryArity(3,objectSet,[t])))):t[c[0]]=c[1]}return 0==e.length?t:promiseAll(e).then(always(t))},mapSet=function(r,n,t){return r.set(n,t)},mapMapEntriesForEachCallback=(r,n,t)=>function(e,o){const c=r([o,e]);isPromise(c)?t.push(c.then(spread2(curryArity(3,mapSet,[n])))):n.set(c[0],c[1])},mapMapEntries=function(r,n){const t=new Map,e=[];return r.forEach(mapMapEntriesForEachCallback(n,t,e)),0==e.length?t:promiseAll(e).then(always(t))},map=r=>function(n){return isArray(n)?arrayMap(n,r):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionMap(n,r):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionMap(n,r):reducerMap(n,r):null==n?n:"function"==typeof n.then?n.then(r):"function"==typeof n.map?n.map(r):"string"==typeof n||n.constructor==String?stringMap(n,r):n.constructor==Set?setMap(n,r):n.constructor==Map?mapMap(n,r):n.constructor==Object?objectMap(n,r):"function"==typeof n[symbolIterator]?MappingIterator(n[symbolIterator](),r):"function"==typeof n[symbolAsyncIterator]?MappingAsyncIterator(n[symbolAsyncIterator](),r):r(n)};map.entries=function(r){return function(n){if(null==n)throw new TypeError("value is not an Object or Map");if(n.constructor==Object)return objectMapEntries(n,r);if(n.constructor==Map)return mapMapEntries(n,r);throw new TypeError("value is not an Object or Map")}},map.series=r=>function(n){if(isArray(n))return arrayMapSeries(n,r);throw new TypeError(`${n} is not an Array`)},map.pool=(r,n)=>function(t){if(isArray(t))return arrayMapPool(t,n,r);throw new TypeError(`${t} is not an Array`)},map.withIndex=r=>function(n){if(isArray(n))return arrayMapWithIndex(n,r);throw new TypeError(`${n} is not an Array`)},map.own=r=>function(n){if(isObject(n)&&!isArray(n))return objectMapOwn(n,r);throw new TypeError(`${n} is not an Object`)};export default map;
