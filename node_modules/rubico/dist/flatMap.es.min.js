/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,objectValues=Object.values,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=e=>nativeObjectToString.call(e),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=e=>objectToString(e)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=e=>objectToString(e)==asyncGeneratorFunctionTag,__=Symbol.for("placeholder"),curry3ResolveArg0=(e,r,t)=>function(n){return e(n,r,t)},curry3ResolveArg1=(e,r,t)=>function(n){return e(r,n,t)},curry3ResolveArg2=(e,r,t)=>function(n){return e(r,t,n)},curry3=function(e,r,t,n){return r==__?curry3ResolveArg0(e,t,n):t==__?curry3ResolveArg1(e,r,n):curry3ResolveArg2(e,r,t)},isPromise=e=>null!=e&&"function"==typeof e.then,iteratorReduceAsync=async function(e,r,t){let n=e.next();if(n.done)return t;for(;!n.done;)t=r(t,n.value),isPromise(t)&&(t=await t),n=e.next();return t},iteratorReduce=function(e,r,t){let n=e.next();if(n.done)return t;for(void 0===t&&(t=n.value,n=e.next());!n.done;){if(t=r(t,n.value),isPromise(t))return t.then(curry3(iteratorReduceAsync,e,r,__));n=e.next()}return t},asyncIteratorReduce=async function(e,r,t){let n=await e.next();if(n.done)return t;for(void 0===t&&(t=n.value,n=await e.next());!n.done;)t=await r(t,n.value),n=await e.next();return t},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,curry2ResolveArg0=(e,r)=>function(t){return e(t,r)},curry2ResolveArg1=(e,r)=>function(t){return e(r,t)},curry2=function(e,r,t){return r==__?curry2ResolveArg0(e,t):curry2ResolveArg1(e,r)},curryArgs3ResolveArgs0=(e,r,t)=>function(...n){return e(n,r,t)},curryArgs3ResolveArgs1=(e,r,t)=>function(...n){return e(r,n,t)},curryArgs3ResolveArgs2=(e,r,t)=>function(...n){return e(r,t,n)},curryArgs3=function(e,r,t,n){return r==__?curryArgs3ResolveArgs0(e,t,n):t==__?curryArgs3ResolveArgs1(e,r,n):curryArgs3ResolveArgs2(e,r,t)},curry4ResolveArg0=(e,r,t,n)=>function(o){return e(o,r,t,n)},curry4ResolveArg1=(e,r,t,n)=>function(o){return e(r,o,t,n)},curry4ResolveArg2=(e,r,t,n)=>function(o){return e(r,t,o,n)},curry4ResolveArg3=(e,r,t,n)=>function(o){return e(r,t,n,o)},curry4=function(e,r,t,n,o){return r==__?curry4ResolveArg0(e,t,n,o):t==__?curry4ResolveArg1(e,r,n,o):n==__?curry4ResolveArg2(e,r,t,o):curry4ResolveArg3(e,r,t,n)},arrayReduceAsync=async function(e,r,t,n){const o=e.length;for(;++n<o;)t=r(t,e[n],n,e),isPromise(t)&&(t=await t);return t},arrayReduce=function(e,r,t){const n=e.length;let o=-1;for(void 0===t&&(t=e[++o]);++o<n;)if(t=r(t,e[o],o,e),isPromise(t))return t.then(curry4(arrayReduceAsync,e,r,__,o));return t},curry5ResolveArg0=(e,r,t,n,o)=>function(c){return e(c,r,t,n,o)},curry5ResolveArg1=(e,r,t,n,o)=>function(c){return e(r,c,t,n,o)},curry5ResolveArg2=(e,r,t,n,o)=>function(c){return e(r,t,c,n,o)},curry5ResolveArg3=(e,r,t,n,o)=>function(c){return e(r,t,n,c,o)},curry5ResolveArg4=(e,r,t,n,o)=>function(c){return e(r,t,n,o,c)},curry5=function(e,r,t,n,o,c){return r==__?curry5ResolveArg0(e,t,n,o,c):t==__?curry5ResolveArg1(e,r,n,o,c):n==__?curry5ResolveArg2(e,r,t,o,c):o==__?curry5ResolveArg3(e,r,t,n,c):curry5ResolveArg4(e,r,t,n,o)},objectKeys=Object.keys,objectGetFirstKey=function(e){for(const r in e)return r},objectReduceAsync=async function(e,r,t,n,o){const c=n.length;for(;++o<c;){const c=n[o];t=r(t,e[c],c,e),isPromise(t)&&(t=await t)}return t},objectReduce=function(e,r,t){const n=objectKeys(e),o=n.length;let c=-1;for(void 0===t&&(t=e[n[++c]]);++c<o;){const o=n[c];if(t=r(t,e[o],o,e),isPromise(t))return t.then((s=objectReduceAsync,a=r,u=__,l=n,f=c,(i=e)==__?curry5ResolveArg0(s,a,u,l,f):a==__?curry5ResolveArg1(s,i,u,l,f):u==__?curry5ResolveArg2(s,i,a,l,f):l==__?curry5ResolveArg3(s,i,a,u,f):curry5ResolveArg4(s,i,a,u,l)))}var s,i,a,u,l,f;return t},mapReduceAsync=async function(e,r,t,n){for(const[o,c]of n)t=r(t,c,o,e),isPromise(t)&&(t=await t);return t},mapReduce=function(e,r,t){const n=e.entries();if(void 0===t){const e=n.next();if(e.done)return t;t=e.value[1]}for(const[o,c]of n)if(t=r(t,c,o,e),isPromise(t))return t.then(curry4(mapReduceAsync,e,r,__,n));return t},funcConcatSync=(e,r)=>function(...t){return r(e(...t))},generatorFunctionReduce=(e,r,t)=>funcConcatSync(e,curry3(iteratorReduce,__,r,t)),asyncGeneratorFunctionReduce=(e,r,t)=>funcConcatSync(e,curry3(asyncIteratorReduce,__,r,t)),reducerConcat=(e,r)=>function(t,n){const o=e(t,n);return isPromise(o)?o.then(curry2(r,__,n)):r(o,n)},genericReduce=function(e,r,t){const n=e[0];return isArray(n)?arrayReduce(n,r,t):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionReduce(n,r,t):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionReduce(n,r,t):curryArgs3(genericReduce,__,1==e.length?reducerConcat(r,n):e.reduce(reducerConcat,r),t):null==n?void 0===t?curry2(r,n,__):r(t,n):n.constructor==Map?mapReduce(n,r,t):"function"==typeof n[symbolIterator]?iteratorReduce(n[symbolIterator](),r,t):"function"==typeof n[symbolAsyncIterator]?asyncIteratorReduce(n[symbolAsyncIterator](),r,t):"function"==typeof n.reduce?n.reduce(r,t):"function"==typeof n.chain?n.chain(curry2(r,t,__)):"function"==typeof n.flatMap?n.flatMap(curry2(r,t,__)):n.constructor==Object?objectReduce(n,r,t):void 0===t?curry2(r,n,__):r(t,n)},arrayPush=function(e,r){return e.push(r),e},FlatMappingIterator=function(e,r){let t=[],n=0;return{[symbolIterator](){return this},next(){if(n<t.length){const e=t[n];return n+=1,{value:e,done:!1}}const o=e.next();if(o.done)return o;const c=genericReduce([r(o.value)],arrayPush,[]);return c.length>1&&(t=c,n=1),{value:c[0],done:!1}}}},FlatMappingAsyncIterator=function(e,r){const t=[],n=new Set;return{[symbolAsyncIterator](){return this},toString:()=>"[object FlatMappingAsyncIterator]",async next(){if(t.length>0)return{value:t.shift(),done:!1};const{value:o,done:c}=await e.next();if(c){for(;n.size>0;)if(await new Promise((e=>setTimeout(e,25))),t.length>0)return{value:t.shift(),done:!1};return{value:void 0,done:!0}}const s=r(o);if(isPromise(s)){const e=s.then(curryArgs3(genericReduce,__,arrayPush,t)).then((()=>n.delete(e)));n.add(e)}else{const e=genericReduce([s],arrayPush,t);if(t.length>0)return{value:t.shift(),done:!1};if(isPromise(e)){const r=e.then((()=>n.delete(r)));n.add(r)}}for(;n.size>0;)if(await new Promise((e=>setTimeout(e,25))),t.length>0)return{value:t.shift(),done:!1};return{value:void 0,done:!0}}}},isBinary=ArrayBuffer.isView,always=e=>function(){return e},getArg1=(e,r)=>r,identity=e=>e,promiseAll=Promise.all.bind(Promise),asyncIteratorForEach=async function(e,r){const t=[];for await(const n of e){const e=r(n);isPromise(e)&&t.push(e)}return 0==t.length?e:promiseAll(t).then(always(e))},arrayFlatten=function(e){const r=e.length,t=[],n=[];let o=-1;for(;++o<r;){const r=e[o];if(isArray(r)){const e=r.length;let t=-1;for(;++t<e;)n.push(r[t])}else if(null==r)n.push(r);else if("function"==typeof r.then)t.push(r.then(curry2(arrayPush,n,__)));else if("function"==typeof r[symbolIterator])for(const e of r)n.push(e);else if("function"==typeof r[symbolAsyncIterator])t.push(asyncIteratorForEach(r[symbolAsyncIterator](),curry2(arrayPush,n,__)));else if("function"==typeof r.chain){const e=r.chain(identity);isPromise(e)?t.push(e.then(curry2(arrayPush,n,__))):n.push(e)}else if("function"==typeof r.flatMap){const e=r.flatMap(identity);isPromise(e)?t.push(e.then(curry2(arrayPush,n,__))):n.push(e)}else if("function"==typeof r.reduce){const e=r.reduce(funcConcatSync(getArg1,curry2(arrayPush,n,__)),null);isPromise(e)&&t.push(e)}else if(r.constructor==Object)for(const e in r)n.push(r[e]);else n.push(r)}return 0==t.length?n:promiseAll(t).then(always(n))},arrayMap=function(e,r){const t=e.length,n=Array(t);let o=-1,c=!1;for(;++o<t;){const t=r(e[o],o,e);isPromise(t)&&(c=!0),n[o]=t}return c?promiseAll(n):n},arrayFlatMap=function(e,r){const t=arrayMap(e,r);return isPromise(t)?t.then(arrayFlatten):arrayFlatten(t)},promiseObjectAllExecutor=e=>function(r){const t={};let n=0;for(const o in e){const c=e[o];isPromise(c)?(n+=1,c.then((e=>function(o){t[e]=o,n-=1,0==n&&r(t)})(o))):t[o]=c}0==n&&r(t)},promiseObjectAll=e=>new Promise(promiseObjectAllExecutor(e)),objectMap=function(e,r){const t={};let n=!1;for(const o in e){const c=r(e[o],o,e);isPromise(c)&&(n=!0),t[o]=c}return n?promiseObjectAll(t):t},objectAssign=Object.assign,objectFlatten=function(e){const r=[],t={},n=curry2(objectAssign,t,__),o=funcConcatSync(getArg1,n);for(const c in e){const s=e[c];if(null!=s)if("function"==typeof s[symbolIterator])for(const e of s)objectAssign(t,e);else if("function"==typeof s[symbolAsyncIterator])r.push(asyncIteratorForEach(s[symbolAsyncIterator](),n));else if("function"==typeof s.chain){const e=s.chain(identity);isPromise(e)?r.push(e.then(n)):objectAssign(t,e)}else if("function"==typeof s.flatMap){const e=s.flatMap(identity);isPromise(e)?r.push(e.then(n)):n(e)}else if("function"==typeof s.reduce){const e=s.reduce(o,null);isPromise(e)&&r.push(e)}else objectAssign(t,s)}return 0==r.length?t:promiseAll(r).then((()=>t))},objectFlatMap=function(e,r){const t=objectMap(e,r);return isPromise(t)?t.then(objectFlatten):objectFlatten(t)},callPropUnary=(e,r,t)=>e[r](t),setMap=function(e,r){const t=new Set,n=[];for(const o of e){const c=r(o,o,e);isPromise(c)?n.push(c.then(curry3(callPropUnary,t,"add",__))):t.add(c)}return 0==n.length?t:promiseAll(n).then(always(t))},setFlatten=function(e){e.size;const r=[],t=new Set,n=(e,r)=>t.add(r),o=curry3(callPropUnary,t,"add",__);for(const c of e)if(isArray(c)){const e=c.length;let r=-1;for(;++r<e;)t.add(c[r])}else if(null==c)t.add(c);else if("function"==typeof c[symbolIterator])for(const e of c)t.add(e);else if("function"==typeof c[symbolAsyncIterator])r.push(asyncIteratorForEach(c[symbolAsyncIterator](),o));else if("function"==typeof c.chain){const e=c.chain(identity);isPromise(e)?r.push(e.then(o)):t.add(e)}else if("function"==typeof c.flatMap){const e=c.flatMap(identity);isPromise(e)?r.push(e.then(o)):t.add(e)}else if("function"==typeof c.reduce){const e=c.reduce(n,null);isPromise(e)&&r.push(e)}else if(c.constructor==Object)for(const e in c)t.add(c[e]);else t.add(c);return 0==r.length?t:promiseAll(r).then((()=>t))},setFlatMap=function(e,r){const t=setMap(e,r);return isPromise(t)?t.then(setFlatten):setFlatten(t)},funcConcat=(e,r)=>function(...t){const n=e(...t);return isPromise(n)?n.then(r):r(n)},arrayJoin=(e,r)=>e.join(r),arrayFlattenToString=funcConcat(arrayFlatten,curry2(arrayJoin,__,"")),stringFlatMap=function(e,r){const t=arrayMap(e,r);return isPromise(t)?t.then(arrayFlattenToString):arrayFlattenToString(t)},streamWrite=function(e,r,t,n){return e.write(r,t,n),e},streamFlatExtend=async function(e,r){const t=curry2(streamWrite,e,__),n=funcConcatSync(getArg1,t),o=[];if(isArray(r)){const t=r.length;let n=-1;for(;++n<t;)e.write(r[n])}else if(null==r)e.write(r);else if("function"==typeof r[symbolIterator])for(const t of r)e.write(t);else if("function"==typeof r[symbolAsyncIterator])o.push(asyncIteratorForEach(r[symbolAsyncIterator](),t));else if("function"==typeof r.chain){const n=r.chain(identity);isPromise(n)?o.push(n.then(t)):e.write(n)}else if("function"==typeof r.flatMap){const n=r.flatMap(identity);isPromise(n)?o.push(n.then(t)):e.write(n)}else if("function"==typeof r.reduce){const e=r.reduce(n,null);isPromise(e)&&o.push(e)}else if(r.constructor==Object)for(const t in r)e.write(r[t]);else e.write(r);return 0==o.length?e:promiseAll(o).then(always(e))},streamFlatMap=async function(e,r){const t=new Set;for await(const n of e){const o=r(n);if(isPromise(o)){const r=o.then(curry2(streamFlatExtend,e,__)).then((()=>t.delete(r)));t.add(r)}else{const r=streamFlatExtend(e,o);if(isPromise(r)){const e=r.then((()=>t.delete(e)));t.add(e)}}}return await promiseAll(t),e},globalThisHasBuffer="function"==typeof Buffer,noop=function(){},bufferAlloc=globalThisHasBuffer?Buffer.alloc:noop,_binaryExtend=function(e,r){const t=e.length,n=globalThisHasBuffer&&e.constructor==Buffer?bufferAlloc(t+r.length):new e.constructor(t+r.length);return n.set(e),n.set(r,t),n},binaryExtend=function(e,r){return isArray(r)||isBinary(r)?_binaryExtend(e,r):_binaryExtend(e,[r])},arrayJoinToBinary=function(e,r){const t=e.length;let n=-1,o=r;for(;++n<t;)o=binaryExtend(o,e[n]);return o},arrayFlattenToBinary=function(e,r){const t=arrayFlatten(e);return isPromise(t)?t.then(curry2(arrayJoinToBinary,__,r)):arrayJoinToBinary(t,r)},binaryFlatMap=function(e,r){const t=arrayMap(e,r),n=globalThisHasBuffer&&e.constructor==Buffer?bufferAlloc(0):new e.constructor(0);return isPromise(t)?t.then(curry2(arrayFlattenToBinary,__,n)):arrayFlattenToBinary(t,n)},reducerFlatMap=(e,r)=>function(t,n){const o=r(n);return isPromise(o)?o.then(curryArgs3(genericReduce,__,e,t)):genericReduce([o],e,t)},generatorFunctionFlatMap=(e,r)=>function*(...t){yield*FlatMappingIterator(e(...t),r)},asyncGeneratorFunctionFlatMap=(e,r)=>async function*(...t){yield*FlatMappingAsyncIterator(e(...t),r)},flatMap=e=>function(r){if(isArray(r))return arrayFlatMap(r,e);if("function"==typeof r)return isGeneratorFunction(r)?generatorFunctionFlatMap(r,e):isAsyncGeneratorFunction(r)?asyncGeneratorFunctionFlatMap(r,e):reducerFlatMap(r,e);if(isBinary(r))return binaryFlatMap(r,e);if(null==r)return e(r);if("function"==typeof r.then)return r.then(e);if("function"==typeof r.next)return symbolIterator in r?FlatMappingIterator(r,e):FlatMappingAsyncIterator(r,e);if("function"==typeof r.chain)return r.chain(e);if("function"==typeof r.flatMap)return r.flatMap(e);if("function"==typeof r[symbolAsyncIterator]&&"function"==typeof r.write)return streamFlatMap(r,e);const t=r.constructor;return t==Object?objectFlatMap(r,e):t==Set?setFlatMap(r,e):"string"==typeof r||t==String?stringFlatMap(r,e):e(r)};export default flatMap;
